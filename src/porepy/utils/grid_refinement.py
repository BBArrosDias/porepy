import logging
import gmsh
from typing import (  # noqa
    Any,
    Coroutine,
    Generator,
    Generic,
    Iterable,
    List,
    Mapping,
    Optional,
    Set,
    Tuple,
    Type,
    TypeVar,
    Union,
)
from pathlib import Path

import porepy as pp
from porepy.fracs.simplex import tetrahedral_grid_from_gmsh
from porepy.fracs.meshing import grid_list_to_grid_bucket
import numpy as np
import scipy.sparse as sps

logger = logging.getLogger(__name__)


def refine_mesh_by_splitting(
        in_file: Union[str, Path],
        out_file: Union[str, Path],
        dim: int,
        network: Union[pp.FractureNetwork3d, pp.FractureNetwork2d],
        gb_set_projections: bool = True,
) -> Generator[pp.GridBucket, None, None]:
    """ Refine a mesh by splitting using gmsh

    The method generates refinements on the fly by yielding GridBuckets as desired.

    Note:
    When the desired number of refinements is reached, you should call
        refine_mesh_by_splitting.close()
    so that gmsh.finalize() is called.

    Parameters
    ----------
    in_file : Union[str, Path]
        path to .geo file to read
    out_file : Union[str, Path]
        path to new .msh file to store mesh in, excluding the ending '.msh'.
    dim : int {2, 3}
        Dimension of domain to mesh
    network : Union[pp.FractureNetwork2d, pp.FractureNetwork3d]
        PorePy class defining the fracture network that is described by the .geo in_file
    gb_set_projections : bool (Default: True)
        Call pp.contact_conditions.set_projections(gb) before yielding result
    Returns
    -------
    Generator[gb]
        A generator for the refined grid buckets, starting with the coarsest.
    """
    # Ensure that in- and out paths are formatted correctly.
    assert Path(in_file).is_file()
    out_file = Path(out_file)
    out_file = out_file.parent / out_file.stem



    # gmsh must always be finalized after it has be initialized (see 'finally' clause).
    # Therefore, we wrap the entire function body in a try-finally context.
    try:
        # Initialize gmsh and generate the first (coarsest) mesh
        gmsh.initialize()
        gmsh.open(in_file)
        gmsh.model.mesh.generate(dim=dim)

        num_refinements = 0

        # Enter an infinite loop
        while True:
            out_file_name = f"{out_file}_{num_refinements}.msh"

            # The first mesh is already done. Start refining all subsequent meshes.
            if num_refinements > 0:
                gmsh.model.mesh.refine()  # Refine the mesh

            gmsh.write(out_file_name)  # Write the result to '.msh' file
            # Generate List[pp.Grid]
            grids = tetrahedral_grid_from_gmsh(network=network, file_name=out_file_name)
            # Convert List[pp.Grid] to pp.GridBucket
            gb = grid_list_to_grid_bucket(grids)

            # Set projection operators for mixed-dimensional grids
            if gb_set_projections:
                pp.contact_conditions.set_projections(gb)

            # yield the resulting grid bucket
            yield gb

            # finally, prepare the next iteration
            num_refinements += 1
    finally:
        # When refine_mesh_by_splitting.close() is called, we get here.
        gmsh.finalize()


def gb_coarse_fine_cell_mapping(gb: pp.GridBucket, gb_ref: pp.GridBucket, tol=1e-8):
    """ Wrapper for coarse_fine_cell_mapping to construct mapping for grids in
    GridBucket.

    Adds a node_prop to each grid in gb. The key is 'coarse_fine_cell_mapping',
    and is the mapping generated by 'coarse_fine_cell_mapping(...)'.

    Note: No node prop is added to the reference grids in gb_ref.

    Parameters
    ----------
    gb : pp.GridBucket
        Coarse grid bucket
    gb_ref : pp.GridBucket
        Refined grid bucket
    tol : float, Optional
        Tolerance for point_in_poly* -methods
    """

    grids = gb.get_grids()
    grids_ref = gb_ref.get_grids()

    assert len(grids) == len(
        grids_ref
    ), "Weakly check that GridBuckets refer to same domains"
    assert np.allclose(
        np.append(*gb.bounding_box()), np.append(*gb_ref.bounding_box())
    ), "Weakly check that GridBuckets refer to same domains"

    # This method assumes a consistent node ordering between grids. At least assign one.
    gb.assign_node_ordering(overwrite_existing=False)
    gb_ref.assign_node_ordering(overwrite_existing=False)

    # Add node prop on the coarse grid to map from coarse to fine cells.
    gb.add_node_props(keys="coarse_fine_cell_mapping")

    for i in np.arange(len(grids)):
        g, g_ref = grids[i], grids_ref[i]

        node_num, node_num_ref = (
            gb._nodes[g]["node_number"],
            gb_ref._nodes[g_ref]["node_number"],
        )
        assert node_num == node_num_ref, "Weakly check that grids refer to same domain."

        # Compute the mapping for this grid-pair,
        # and assign the result to the node of the coarse gb
        mapping = pp.refinement.coarse_fine_cell_mapping(g, g_ref, point_in_poly_tol=tol)
        gb.set_node_prop(g=g, key="coarse_fine_cell_mapping", val=mapping)


